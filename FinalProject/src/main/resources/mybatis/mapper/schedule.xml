<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.spring.app.schedule.model.ScheduleDAO">

    <resultMap id="ScheduleMap" type="com.spring.app.schedule.domain.ScheduleDTO">
        <id     property="scheduleNo"    column="schedule_no"/>
        <result property="fkEmpNo"       column="fk_emp_no"/>
        <result property="scheduleTitle" column="schedule_title"/>
        <result property="startDate"     column="start_date"/>
        <result property="endDate"       column="end_date"/>
        <result property="scheduleDetail" column="schedule_detail"/>
        <result property="loc"           column="loc"/>
    </resultMap>

    <!-- 기간과 겹치는 일정 조회 + (선택) 사원/키워드 필터 -->
    <select id="selectSchedulesInRange" resultMap="ScheduleMap" parameterType="map">
	  SELECT schedule_no,
	         fk_emp_no,
   			 schedule_title,
    		 start_date,
	    	 end_date,
	   	     schedule_detail,
	    	 loc
	  FROM tbl_schedule
	  WHERE start_date &lt; #{end,   jdbcType=TIMESTAMP}
	    AND end_date   &gt; #{start, jdbcType=TIMESTAMP}
	    AND fk_emp_no  = #{empNo, jdbcType=VARCHAR}   
	  <if test="q != null and q != ''">
	    AND (
	         LOWER(schedule_title)  LIKE '%' || LOWER(#{q}) || '%'
	      OR LOWER(schedule_detail) LIKE '%' || LOWER(#{q}) || '%'
	    )
	  </if>
	  ORDER BY start_date ASC, schedule_no ASC
	</select>


	<!-- 일정 등록하기 -->
	<insert id="createSchedule" parameterType="com.spring.app.schedule.domain.ScheduleDTO">

	  <!-- 1) PK를 미리 뽑아 DTO.scheduleNo 에 세팅 -->
	  <selectKey keyProperty="scheduleNo" resultType="string" order="BEFORE">
	    <!-- 자리수 관리가 필요하면 LPAD 사용: LPAD(TO_CHAR(seq_tbl_schedule.NEXTVAL),10,'0') -->
	    SELECT TO_CHAR(seq_tbl_schedule.NEXTVAL) FROM dual
	  </selectKey>
	
	  <!-- 2) 일반 INSERT (날짜/문자 바인딩은 함수 없이 JDBC 타입으로) -->
	  INSERT INTO tbl_schedule (
	    schedule_no,
	    fk_emp_no,
	    schedule_title,
	    start_date,
	    end_date,
	    schedule_detail,
	    loc
	  ) VALUES (
	    #{scheduleNo,    jdbcType=VARCHAR},
	    #{fkEmpNo,       jdbcType=VARCHAR},
	    #{scheduleTitle, jdbcType=VARCHAR},
	    #{startDate,     jdbcType=TIMESTAMP},
	    #{endDate,       jdbcType=TIMESTAMP},
	    #{scheduleDetail,jdbcType=VARCHAR},
	    #{loc,           jdbcType=VARCHAR}
	  )
	</insert>
	
	
	<!-- 일정 삭제: 내 일정만 삭제 -->
	<delete id="deleteScheduleByOwner">
	    DELETE FROM tbl_schedule
	    WHERE schedule_no = #{scheduleNo}
	    AND fk_emp_no = #{empNo}
	</delete>


	<!-- 일정 수정하기: 내 일정만 수정 -->
	<update id="updateOwnSchedule" parameterType="com.spring.app.schedule.domain.ScheduleDTO">
	  UPDATE tbl_schedule
	  SET schedule_title   = #{scheduleTitle},
	      start_date       = #{startDate, jdbcType=TIMESTAMP},
	      end_date         = #{endDate,   jdbcType=TIMESTAMP},
	      schedule_detail  = #{scheduleDetail, jdbcType=VARCHAR},
	      loc              = #{loc, jdbcType=VARCHAR}
	  WHERE schedule_no = #{scheduleNo}
	    AND fk_emp_no   = #{fkEmpNo}
	</update>
	
	<!-- 검색: 내 일정만 + 제목/메모 LIKE + (옵션)기간 + 상위 N건 -->
	<select id="selectSearchResults" parameterType="map" resultMap="ScheduleMap">
	  SELECT *
	  FROM (
	  	    SELECT schedule_no, fk_emp_no, schedule_title, start_date, end_date, schedule_detail, loc
	        FROM tbl_schedule
	        WHERE fk_emp_no = #{empNo}
	        <if test="q != null and q != ''">
	          AND (LOWER(schedule_title)  LIKE '%' || LOWER(#{q}) || '%'
	               OR LOWER(schedule_detail) LIKE '%' || LOWER(#{q}) || '%')
	        </if>
	        <if test="from != null">
	          AND end_date   &gt;= #{from,jdbcType=TIMESTAMP}
	        </if>
	        <if test="to != null">
	          AND start_date &lt;= #{to,jdbcType=TIMESTAMP}
	        </if>
      		  ORDER BY start_date DESC, schedule_no DESC
	       )
	</select>
	
	
	
	<resultMap id="TaskMap" type="com.spring.app.schedule.domain.TaskDTO">
        <id     property="taskNo"    column="task_no"/>
        <result property="taskTitle"       column="task_title"/>
        <result property="taskDetail" column="task_detail"/>
        <result property="startDate"     column="start_date"/>
        <result property="endDate"       column="end_date"/>
        <result property="deptNo" column="dept_No"/>
    </resultMap>

    <!-- 부서일정(업무) 불러오기 -->
    <select id="selectSchedulesInRange2" parameterType="map" resultMap="TaskMap">
	    SELECT t.task_no
	      	 , t.task_title
	     	 , t.task_detail
	      	 , t.start_date
	      	 , t.end_date
	      	 , NVL(td.fk_dept_no, #{deptNo}) AS dept_no
	    FROM tbl_task t
	   
	    LEFT JOIN tbl_task_department td
	           ON td.fk_task_no = t.task_no
	          AND td.fk_dept_no = #{deptNo}
	    WHERE
	          /* FullCalendar 기간 교집합: [start, end) vs [start_date, end_date] */
	          t.start_date &lt; #{end}
	      AND t.end_date   &gt;= #{start}
	
	      /* 부서 매핑이 있거나, 부서 ACCESS로 공개된 업무이거나 */
	      AND (
	            td.fk_dept_no IS NOT NULL
	         OR EXISTS (
	              SELECT 1
	                FROM tbl_task_access ta
	               WHERE ta.fk_task_no  = t.task_no
	                 AND ta.target_type = 'dept'
	                 AND ta.target_no   = #{deptNo}
	            )
	          )
	
	      <if test="q != null and q.trim() != ''">
	        AND (
	              INSTR(LOWER(t.task_title),  LOWER(#{q})) > 0
	           OR INSTR(LOWER(t.task_detail), LOWER(#{q})) > 0
	        )
	      </if>
	
	    ORDER BY t.start_date ASC, t.task_no ASC
  </select>
	
	
	



</mapper>
